# Cursor Agent Rules for Discernus Project

## Critical Regression Remediation: Test-Driven Development (TDD) Protocol

### When Critical Regressions Are Identified
- **IMMEDIATE STOP**: Do not attempt live debugging or expensive API-based experiments
- **Document the Issue**: Log in `pm/todo/discernus_v10_backlog.md` with ARCH-XXX identifier
- **Create Remediation Plan**: Document detailed 6-phase TDD approach before any implementation

### 6-Phase TDD Protocol (Proven Success Pattern)
1. **Unit Test Development**: Write focused tests validating regression patterns and expected behavior
2. **Path Bug Investigation**: Identify and fix configuration/path issues with minimal code changes
3. **Core Implementation**: Implement fixes using proven patterns from working code
4. **Integration Testing**: Use mocks to verify end-to-end pipeline logic without API calls
5. **Limited Live Testing**: Create minimal 1-document experiments to validate fixes
6. **Full Validation**: Rerun original experiments to confirm complete resolution

### Cost Containment Rules
- **NO live experiments until Phase 5**: Use unit tests and mocks for 90% of debugging
- **Maximum 1-document tests**: Validate fixes without expensive multi-document runs
- **Document all costs**: Track API usage and justify each live experiment
- **Use proven patterns**: Import working functionality rather than rebuilding from scratch

### Success Criteria
- âœ… Unit tests pass for all regression patterns
- âœ… Integration tests pass with mocked dependencies  
- âœ… Limited live test completes successfully
- âœ… Original experiment reruns without errors
- âœ… Individual processing restored (not batch processing)
- âœ… All artifacts properly structured and accessible

### Documentation Requirements
- Update `docs/developer/` with detailed remediation plans
- Update `pm/todo/discernus_v10_backlog.md` with progress and completion
- Preserve all test files for future regression detection
- Document lessons learned in project memory

# THIN Architecture Rules - Cursor AI must follow these STRICTLY

## ðŸš¨ CRITICAL: ENVIRONMENT MANAGEMENT RULES (Updated August 2025)
- **ENVIRONMENT IS STABLE**: No venv needed, uses system Python 3.13.5
- **USE `discernus` command directly** - it's installed as an entry point
- **NEVER recreate environments** - system is stable and working
- **If imports fail, run `make install`** to fix dependencies
- **Use `make check` to verify environment health**

## âœ… ARCHITECTURAL COMPLIANCE RULES (THIN COMPLIANCE ACHIEVED!)
- **COMPLIANCE STATUS**: âœ… All checks passed - THIN architecture fully compliant
- **PRE-COMMIT CHECK**: Run `python3 scripts/compliance_tools/thin_compliance_check.py` to verify continued compliance
- **THIN FIRST**: Tiered limits - Simple <200, Core <400, Complex <600, Orchestration <800 lines
- **YAML EXTERNALIZATION**: All prompts in .yaml files, never inline in Python code
- **NO COMPLEX PARSING**: Trust LLM output, use envelope extraction over parsing
- **ACADEMIC INTEGRITY**: All statistics via code execution, complete provenance chains
- **FRAMEWORK AGNOSTIC**: No hardcoded framework assumptions in orchestration
- **REFERENCE**: See docs/developer/CURSOR_AGENT_DISCIPLINE_GUIDE.md for full checklist
- **VIOLATION POLICY**: Any new code that increases violation count will be rejected

## ðŸš¨ CRITICAL: GIT COMMAND RULES  
- **ALWAYS use SHORT commit messages (under 50 characters)**
- **NEVER write long multi-line commit messages**
- **ALWAYS use `git status` before complex git operations**
- **ALWAYS use `gh issue view [number] | cat` (never without | cat)**
- **NEVER use complex git commit messages that can hang terminals**

## âœ… REQUIRED GIT PATTERNS:
```bash
# GOOD - Short commit messages that won't hang
git commit -m "Fix documentation structure"
git commit -m "Add new feature X"
git commit -m "Update config files"

# GOOD - Safe GitHub CLI usage
gh issue view 135 | cat
gh issue list --limit 10
gh auth status

# ALWAYS check status first
git status && git commit -m "Brief message"
```

## ðŸš« FORBIDDEN GIT PATTERNS:
```bash
# BAD - Long messages that can hang AI terminals
git commit -m "Very long commit message with lots of details and explanations that can cause terminal hanging in AI agent environments..."

# BAD - Commands without pager bypass
gh issue view 135  # Can hang indefinitely

# BAD - Complex multi-line operations
git commit -m """
Multi-line message
with lots of details
""" # Can cause hanging
```

## âœ… REQUIRED ENVIRONMENT PATTERNS (Updated August 2025):
```bash
# ALWAYS use these simple, reliable commands:
discernus list                                   # List experiments
discernus run projects/simple_test              # Run experiment
make check                                       # Verify environment

# FAST TESTING (recommended):
discernus run projects/simple_test --skip-validation  # ~47 seconds, $0.014

# LOCAL CONFIG (from experiment directory):
cd projects/simple_test && discernus run .      # Uses local Flash Lite config
```

## ðŸš« FORBIDDEN ENVIRONMENT PATTERNS (Updated August 2025):
- Creating/recreating venv (system is stable)
- Complex Python module paths (use simple `discernus` command)
- Manual framework.md symlinks (canonical paths work automatically)
- Ignoring existing .discernus.yaml configs

## ðŸš¨ FORBIDDEN PATTERNS - NEVER write these:
- import re, regex, bs4, xml.etree (use LLM for parsing instead)
- def parse_*, extract_*, validate_*, analyze_* (use LLM calls instead)
- More than 3 if/elif statements in a function (use LLM logic instead)
- String manipulation like .split(), .replace(), .strip() (use LLM formatting instead)
- Complex try/except blocks with multiple handlers (use LLM error recovery)
- Regex patterns, string parsing, content validation (use LLM processing)

## âœ… REQUIRED PATTERNS - ALWAYS write these:
- Read file â†’ pass to LLM â†’ store result (simple orchestration)
- Route message â†’ call LLM â†’ store response (no processing)
- Maximum 50 lines per function/class (complexity limit)
- Use llm_client.call_llm() for ANY content processing
- Simple file operations, Redis pub-sub, basic routing only
- Store raw LLM responses, don't parse or validate them

## ðŸ¤” BEFORE WRITING ANY CODE, ASK:
1. Could an LLM solve this problem better?
2. Am I building intelligence into software? (Should be NO)
3. Is this simple orchestration/routing? (Should be YES)
4. Am I parsing or validating content? (Should be NO)
5. Could I explain this to a non-programmer? (Should be YES)

## ðŸŽ¯ THIN SUCCESS PATTERNS:
```python
# GOOD - THIN pattern
def load_framework(path):
    content = Path(path).read_text()
    validation = llm_client.call_llm(f"Validate this framework: {content}")
    return {'content': content, 'validation': validation}

# BAD - THICK pattern  
def load_framework(path):
    content = Path(path).read_text()
    if not re.search(r'dimensions?:', content):
        raise ValueError("Missing dimensions")
    # ... complex parsing logic
```

## ðŸ›‘ IF YOU START WRITING PARSING/VALIDATION LOGIC, STOP!
Use LLM calls instead. The software orchestrates, the LLM provides intelligence.

## ðŸš€ SOAR 2.0 SPECIFIC:
- Use Redis pub-sub for agent coordination
- Framework specifications pass to LLM agents as-is
- Store ensemble results without processing
- Let LLMs handle framework application and validation 