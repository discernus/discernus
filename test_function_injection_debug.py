#!/usr/bin/env python3
"""
Focused Test: Function Injection Architecture Issue

This test demonstrates exactly why the statistical results aren't working.
"""

import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, '/Volumes/code/discernus-epic-401')

def test_function_injection_issue():
    """Test the exact function injection problem"""
    print("üîç FUNCTION INJECTION ARCHITECTURE ISSUE")
    print("=" * 60)
    
    # Load the generated notebook
    notebook_file = Path("projects/simple_test/runs/20250817T001427Z/research_notebook.py")
    if not notebook_file.exists():
        print("‚ùå Notebook not found")
        return
        
    with open(notebook_file) as f:
        notebook_content = f.read()
    
    print("üìã NOTEBOOK ANALYSIS:")
    print("-" * 30)
    
    # Check if functions are injected as raw code
    if '{{ statistical_analysis_functions }}' in notebook_content:
        print("‚ùå Template variables not replaced!")
        return
        
    # Check if functions are defined in the notebook
    function_definitions = [
        'def calculate_basic_statistics',
        'def perform_statistical_analysis',
        'def calculate_derived_metrics'
    ]
    
    for func in function_definitions:
        if func in notebook_content:
            print(f"‚úÖ {func} defined in notebook")
        else:
            print(f"‚ùå {func} NOT defined in notebook")
    
    # Check if functions are called
    function_calls = [
        'perform_statistical_analysis(derived_results)',
        'calculate_derived_metrics(analysis_data)'
    ]
    
    for call in function_calls:
        if call in notebook_content:
            print(f"‚úÖ {call} called in notebook")
        else:
            print(f"‚ùå {call} NOT called in notebook")
    
    print("\nüîç FUNCTION INJECTION METHOD:")
    print("-" * 30)
    
    # Look for the function injection section
    if 'COMPUTATIONAL FUNCTIONS - Generated by v8.0 Agents' in notebook_content:
        print("‚úÖ Function injection section found")
        
        # Find where functions are injected
        lines = notebook_content.split('\n')
        for i, line in enumerate(lines):
            if 'COMPUTATIONAL FUNCTIONS' in line:
                print(f"üìç Function section starts at line {i+1}")
                # Show next few lines
                for j in range(i+1, min(i+10, len(lines))):
                    if lines[j].strip() and not lines[j].startswith('#'):
                        print(f"   Line {j+1}: {lines[j][:80]}...")
                        break
                break
    else:
        print("‚ùå Function injection section not found")
    
    print("\nüîç NAMESPACE ISSUE ANALYSIS:")
    print("-" * 30)
    
    # Check if there are any import statements
    import_lines = [line for line in notebook_content.split('\n') if line.strip().startswith('from') or line.strip().startswith('import')]
    
    if import_lines:
        print("üì• Import statements found:")
        for line in import_lines[:5]:  # Show first 5
            print(f"   {line.strip()}")
    else:
        print("‚ùå No import statements found")
    
    # Check if functions are defined at module level
    if 'def calculate_basic_statistics(' in notebook_content:
        print("‚úÖ calculate_basic_statistics defined at module level")
    else:
        print("‚ùå calculate_basic_statistics not defined at module level")
    
    print("\nüéØ ROOT CAUSE SUMMARY:")
    print("-" * 30)
    print("The issue is that functions are being injected as raw Python code")
    print("into the notebook template, but they're not being properly imported")
    print("or made available in the notebook's namespace.")
    print("\nThis creates a situation where:")
    print("1. Functions exist in the notebook file")
    print("2. But they're not accessible when called")
    print("3. Leading to NameError exceptions")
    print("4. Which fall back to placeholder values")

if __name__ == "__main__":
    test_function_injection_issue()
